# 排序（Sort）介紹與應用

## 一、什麼是排序？

排序是指將一組資料按特定順序（通常遞增或遞減）重新排列的過程。它是電腦科學中最基礎且重要的演算法之一，許多問題的解決方案依賴於有序資料。排序演算法的選擇取決於資料規模、資料特性（如是否部分排序）以及應用場景。

### 排序的實際應用

- **資料庫查詢**：資料庫記錄按姓名、價格等排序以加速檢索或呈現（如電商網站按價格排序商品）。
- **搜尋引擎**：搜尋結果按相關性或時間排序（如 Google 搜尋結果）。
- **任務排程**：作業系統或工作管理工具按優先級或截止日期排序任務（如 [Trello](https://trello.com/zh-Hant) 任務清單）。
- **資料視覺化**：圖表或報表資料按特定欄位排序以便分析（如 Excel 資料表）。
- **演算法基礎**：許多演算法（如二分搜尋）要求資料已排序。
- **遊戲開發**：排行榜按分數排序（如線上遊戲的全球排行榜）。

### 為什麼學習排序？

- **效率**：不同排序演算法在時間和空間複雜度上差異顯著，選擇合適演算法可提升程式效能。
- **基礎性**：排序是許多複雜演算法和資料結構的基礎。
- **實用性**：排序應用廣泛，幾乎每個程式設計領域都會用到。

## 二、常見排序演算法

以下介紹四種常見的排序演算法，涵蓋原理、時間複雜度、優缺點及適用場景，適合基礎課程講解。
### 1. 泡沫排序（Bubble Sort）

- **原理**：反覆比較相鄰元素，若順序錯誤則交換，直到沒有交換為止。較大元素像「氣泡」逐漸「浮」到陣列末端。
- **時間複雜度**：
  - 最佳：O(n)（資料已排序）
  - 平均/最差：O(n²)
- **空間複雜度**：O(1)（原地排序）
- **優點**：
  - 程式碼簡單，易於理解和實現。
  - 適合小規模資料或教學展示。
- **缺點**：
  - 效率低，不適合大規模資料。
- **適用場景**：
  - 小陣列排序（n < 100）。
  - 資料幾乎已排序時（可加入旗標優化）。

### 2. 選擇排序（Selection Sort）

- **原理**：每次從未排序部分選出最小（或最大）元素，放到已排序部分的末端。
- **時間複雜度**：
  - 最佳/平均/最差：O(n²)
- **空間複雜度**：O(1)（原地排序）
- **優點**：
  - 簡單易懂。
  - 交換次數少（最多 n-1 次），適合交換成本高的場景。
- **缺點**：
  - 效率低，比較次數多。
  - 不適合大規模資料。
- **適用場景**：
  - 小規模資料。
  - 交換操作成本高時（如硬碟資料）。

### 3. 插入排序（Insertion Sort）

- **原理**：將每個元素插入到已排序部分的適當位置，類似整理撲克牌。
- **時間複雜度**：
  - 最佳：O(n)（資料已排序）
  - 平均/最差：O(n²)
- **空間複雜度**：O(1)（原地排序）
- **優點**：
  - 對小規模或部分排序資料效率高。
  - 穩定排序（不改變相等元素的相對順序）。
- **缺點**：
  - 不適合大規模資料。
- **適用場景**：
  - 小陣列或即時資料流（如線上排序）。
  - 資料接近排序時。

### 4. 快速排序（Quick Sort）

- **原理**：選擇一個基準（pivot），將陣列分為小於和大于基準的兩部分，遞迴排序子陣列。
- **時間複雜度**：
  - 最佳/平均：O(n log n)
  - 最差：O(n²)（極少發生，如已排序陣列且基準選擇不佳）
- **空間複雜度**：O(log n)（遞迴堆疊）
- **優點**：
  - 平均效率高，適合大多數場景。
  - 原地排序，空間需求較低。
- **缺點**：
  - 最差情況效率低（可透過隨機基準優化）。
  - 非穩定排序。
- **適用場景**：
  - 大規模資料排序。
  - 通用排序需求（如程式庫中的排序函數）。

## 三、排序演算法比較

| 演算法        | 最佳時間 | 平均時間 | 最差時間 | 空間複雜度 | 穩定性 | 適用場景                     |
|---------------|----------|----------|----------|------------|--------|-----------------------------|
| 泡沫排序      | O(n)     | O(n²)    | O(n²)    | O(1)       | 是     | 小資料、教學                |
| 選擇排序      | O(n²)    | O(n²)    | O(n²)    | O(1)       | 否     | 小資料、交換成本高          |
| 插入排序      | O(n)     | O(n²)    | O(n²)    | O(1)       | 是     | 小資料、部分排序            |
| 快速排序      | O(n log n) | O(n log n) | O(n²)  | O(log n)   | 否     | 大資料、通用排序            |

## 四、程式碼範例（以 Python 實現插入排序）

以下是插入排序的 Python 實作：

```python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]  # 當前要插入的元素
        j = i - 1     # 已排序部分的末端
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]  # 右移较大元素
            j -= 1
        arr[j + 1] = key  # 插入到正確位置
    return arr

# 測試
arr = [64, 34, 25, 12, 22, 11, 90]
sorted_arr = insertion_sort(arr)
print("排序結果：", sorted_arr)

```

### 輸出：
```
排序結果：[11, 12, 22, 25, 34, 64, 90]
```

## 五 Demo

[DEMO1](https://www.toptal.com/developers/sorting-algorithms) <br>
[DEMO2](https://visualgo.net/en/sorting) <br>

## 六 寫出 bubble sort

https://leetcode.com/problems/sort-an-array/description/